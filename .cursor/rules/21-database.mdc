---
alwaysApply: true
---

# Database & Schema Rules (PostgreSQL)

## Core Requirements

- **Database**: PostgreSQL ONLY (no MySQL/SQLite syntax)
- **Migrations**: All schema changes via Laravel migrations in `database/migrations/`
- **Naming**: All entities use `snake_case`

## Naming Conventions

- **Tables**: Plural `snake_case` (e.g., `user_accounts`, `product_variants`, `order_items`)
- **Columns**: Singular `snake_case` (e.g., `first_name`, `is_active`, `created_at`)
- **Foreign Keys**: `{table_name}_id` (e.g., `product_id`, `brand_id`, `user_id`)
- **Primary Keys**: Always `id` (auto-incrementing big integer)
- **Timestamps**: Always include `created_at` and `updated_at` (use `$table->timestamps()`)

## Critical Tables

### Products & Variants

- **`products`**: Base product configuration
  - Key fields: `sku`, `name`, `base_price`, `making_charge`, `variant_options` (JSON), `metal_ids` (array), `is_variant_product`
  - Relationships: `brand_id`, `category_id`, `material_id`
  
- **`product_variants`**: Specific sellable configurations
  - Key fields: `product_id`, `sku`, `label`, `price_adjustment`, `metadata` (JSON), `is_default`
  - Relationships: `product_id` (FK)
  
- **`product_variant_metals`**: Variant-metal associations (many-to-many)
  - Key fields: `product_variant_id`, `metal_id`, `metal_purity_id`, `metal_tone_id`, `weight_grams`, `position`
  
- **`product_variant_diamonds`**: Variant-diamond associations
  - Key fields: `product_variant_id`, `diamond_type_id`, `diamond_shape_id`, `diamond_color_id`, `diamond_clarity_id`, `diamond_cut_id`, `stone_count`, `total_carat`, `position`
  
- **`product_variant_colorstones`**: Variant-colorstone associations
  - Key fields: `product_variant_id`, `colorstone_id`, `colorstone_color_id`, `colorstone_shape_id`, `colorstone_quality_id`, `stone_count`, `total_carat`, `position`

### Catalog Structure

- **`brands`**: Product brands
- **`categories`**: Hierarchical product categories
- **`catalogs`**: Product catalog groups
- **`catalog_products`**: Pivot table for catalog-product associations
- **`materials`**: Material types (Gold, Silver, etc.)
- **`metal_purities`**: Metal purity levels (24K, 22K, 18K, 14K, 999, 958, 925)
- **`metal_tones`**: Metal tones (Yellow, White, Rose, etc.)
- **`sizes`**: Size definitions
- **`styles`**: Product styles

### Commerce Tables

- **`carts`**: Shopping carts
- **`cart_items`**: Cart items (with `product_id`, `variant_id`, `quantity`)
- **`orders`**: Orders
- **`order_items`**: Order line items
- **`order_statuses`**: Order status definitions
- **`order_status_histories`**: Order status change log
- **`quotations`**: Quotation requests
- **`quotation_messages`**: Quotation messaging
- **`payments`**: Payment records
- **`payment_gateways`**: Payment gateway configuration

### Pricing & Offers

- **`price_rates`**: Metal rate records (Gold XAU, Silver XAG)
- **`offers`**: Discount offers
- **`making_charge_discounts`**: Making charge discount rules

### Jobwork & Production

- **`jobwork_requests`**: Jobwork requests
- **`work_orders`**: Production work orders

### Users & KYC

- **`users`**: User accounts (with `type` enum field)
- **`user_kyc_profiles`**: KYC profile information
- **`user_kyc_documents`**: KYC document storage
- **`user_kyc_messages`**: KYC messaging
- **`user_login_otps`**: OTP storage
- **`customer_types`**: Customer type definitions
- **`customer_groups`**: Customer group definitions

### Settings

- **`settings`**: System settings
- **`taxes`**: Tax definitions
- **`tax_groups`**: Tax group definitions

## Migration Best Practices

- **Always add foreign key constraints**: `$table->foreignId('product_id')->constrained()->onDelete('cascade')`
- **Add indexes** on:
  - Foreign keys
  - Status fields (for filtering)
  - Frequently queried columns (SKU, email, etc.)
- **Use appropriate delete behavior**:
  - `cascadeOnDelete()` for children that cannot exist without parent (variants, items)
  - `nullOnDelete()` for optional references (brand, category in some cases)
- **Use `jsonb`** for flexible JSON data (PostgreSQL-specific)
- **Use `decimal` or `numeric`** for financial values (not `float`)
- **Prefer `is_active` flags** over deleting key lookup data (metals, purities, tones, core attributes)

## Data Types

- **Strings**: `string()` or `text()` for longer content
- **Booleans**: `boolean()` (cast to boolean in model)
- **Integers**: `integer()`, `bigInteger()` for IDs
- **Decimals**: `decimal(10, 2)` for prices, weights, rates
- **JSON**: `json()` or `jsonb()` for flexible data (variant_options, metadata)
- **Arrays**: Use JSON columns for arrays (metal_ids, metal_purity_ids)
- **Timestamps**: `timestamp()` or `timestamps()` helper
- **Dates**: `date()` for date-only fields

## Referential Integrity

- **Always define foreign keys** in migrations
- **Set appropriate cascade rules**:
  - Variants cascade delete when product deleted
  - Order items cascade delete when order deleted
  - Cart items cascade delete when cart deleted
- **Use soft deletes** (`$table->softDeletes()`) for important entities that should be recoverable

## Performance Considerations

- **Eager load relationships** in queries: `Product::with(['brand', 'category', 'variants'])->get()`
- **Use `withCount()`** for counts: `Product::withCount('variants')->get()`
- **Add indexes** on columns used in WHERE clauses and JOINs
- **Use `whereHas()`** for filtering by related entities
- **Paginate large result sets**: `paginate(20)` or `simplePaginate(20)`

## Product Variant Schema Rules

- **Keep configuration on `products`**, choices on `product_variants`
- **Avoid duplicating large JSON config** on every variant
- **Store variant-specific data** in `metadata` JSON field
- **Use join tables** for many-to-many relationships (metals, diamonds, colorstones)
- **Include `position` field** in join tables for ordering
